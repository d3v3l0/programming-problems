instructions = """
EPI 16.1 (modified)

You are given a (n x n) grid of cells. All elements in the grid are populated either by 0 or 1. 0 denotes it
is a free cell and 1 denotes it is a blocked cell. You have to start from (0, 0) and reach (i, j).
You are allowed to go either right, left, top or bottom and only on to free cells. Find a path from
the entrance to any other cell in the grid.

ANALYSIS and SOLUTION:
A Breadth First Search (BFS) is used for this problem, given that the graph is unweighted and in the worst case
(the ending cell is [n-1,n-1] for a zero-based n x n grid), every cell is visited, which will cause O(|V|)
runtime performance. According to Skeina (in "The Algorithm Design Manual"), E.F. Moore proves that
a BFS will find the shortest path between two vertices in a graph in his 1959 paper, "The Shortest
Path Through a Maze".

NOTES/PROGRAM FLOW:
The function shortest_path() is the function that solves this problem - it takes a grid generated by
generate_square_grid() (which is a list of lists of ints) as input, and finds the shortest path with a BFS.
shortest_path() calls fetch_adjacencies() for each cell it traverses during the BFS, and then returns
the solution path as a list of lists. The solution path is then passed back to fill_grid_with_path(),
which populates the grid with 2s for each cell in the shortest path. The grid is then displayed by
show() and then the program exits.

By convention, we assume no path exists between [0,0] and cell [i,j] if either contain a 1, so
generate_square_grid() prevents this from ever occuring by explicitly setting both to 0.

USE:
You can simply run the script as-is, and it will generate its own values for the CLI arguments. However,
should you choose to provide them, they are as follows:
    -s      the size of the grid; providing a legitimate value for s will generate an s x s grid.
    -d      maze difficulty; this is a value between 0 and 1 that represents the likelihood of any
            given cell being a 1 instead of a 0. A completely clear grid (i.e. every grid entry is 0)
            has a difficulty of 0, whereas a grid with a difficulty of 1 is impossible to traverse
            (any value larger than 1 will be discarded and randomly regenerated)
    -e      two values, representing the coordinates of the ending cell in (y,x) format.
"""
import sys
import traceback
import random
import argparse

"""
Creates a list of lists representing the grid. The grid is "size x size" (for the input size parameter),
so the returned list is of length size, as is each sublist within it.
"""
def generate_square_grid(size, maze_difficulty, end_cell):
    grid = [[] for i in range(size)]
    for row in grid:
        for column_index in range(size):  # NOTE: grid[0][0] is the uppermost, leftmost cell of the grid
            if(random.random() < maze_difficulty): # higher maze difficulty will correspond to more blocked cells
                row.append(1)
            else:
                row.append(0)
    grid[end_cell[0]][end_cell[1]] = 0
    grid[0][0] = 0
    return grid

"""
Takes a grid generated by generate_square_grid() and a list representing a shortest path,
and then replaces each entry in the grid contained in the path with a 2.
"""
def fill_grid_with_path(grid, path):
    for row_index, column_index in path:
        grid[row_index][column_index] = 2
    return grid


"""
Finds the shortest path between [0,0] and any other cell in a grid generated by
generate_square_grid(), using a BFS graph search algorithm. fetch_adjacencies()
is called for every cell traversed during the BFS.  A dictionary is used to store
which cell precedes a visited cell, and is walked backwards at the end of
the function to create the shortest path. Returns a list of lists indicating the
shortest path.
"""
def shortest_path(grid, end_cell, length):
    current_cell = None
    visited_cells = []
    to_visit = [[0,0]]
    prevs = {} # this dictionary stores how a cell was reached; prevs[cell_n] = cell_n-1
    while current_cell != end_cell and to_visit:
        current_cell = to_visit.pop(0)
        adjacency_list = fetch_adjacencies(grid, current_cell, length)
        for each_cell in adjacency_list:
            if (each_cell not in to_visit) and (each_cell not in visited_cells):
                prevs[tuple(each_cell)] = current_cell
                to_visit.append(each_cell)
        visited_cells.append(current_cell)
    if current_cell != end_cell:
        return False
    # End) - step through prevs, starting at prevs[end_cell], terminating at [0,0], path.insert() each to path
    else:
        path = [current_cell]
        while current_cell != [0,0]:
            parent = prevs[tuple(current_cell)] # walk the prevs list backwards from end_cell
            path.insert(0, parent)
            current_cell = parent
        return path


"""
Takes a grid created by generate_square_grid(), a cell within the grid, and a value
for the grid's length (which is given by the caller to avoid unnecessary recomputations)
and finds all cells adjacent to that cell, appending to them to a list that is
returned. shortest_path() will filter out any cells that are already going to be visited,
and any that have already been visited. Cells are stored in [y,x] format to make accessing
a list-of-lists easier.
"""
def fetch_adjacencies(grid, cell, length):
    adjacency_list = []
    row_index, column_index = cell[0], cell[1]
    possible_adjacencies = [
            [row_index+1, column_index],
            [row_index-1, column_index],
            [row_index, column_index-1],
            [row_index, column_index+1]]
    for row_index, column_index in possible_adjacencies: # this is O(c) because each list has at most 4 entries
        if row_index < 0 or column_index < 0: # don't let grid[-1][-1] be a legitimate value
            continue
        if length <= row_index or length <= column_index: # don't let grid[14][14] be a legitimate value for a zero-based 14 x 14 grid
            continue
        adjacent_cell = grid[row_index][column_index]
        if adjacent_cell == 1: # we can't visit blocked cells, skip them
            continue
        adjacency_list.append([row_index, column_index])
    return adjacency_list


"""
Borrowed this function from some code I was given for a Udacity project.
I don't entirely understand lambda function syntax for Python yet, but all
show() does is nicely display a grid that is represented using lists of lists
(such as ones generated with generate_square_grid()).
"""
def show(p, text=""):
    rows = ['[' + ','.join(map(lambda x: '{0:d}'.format(x),r)) + ']' for r in p]
    print(text)
    print '[' + ',\n '.join(rows) + ']'
    print("\n")

if __name__ == "__main__":
    # Handle inputs
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--size', type=int, default=random.randint(1,25))
    parser.add_argument('-d', '--difficulty', type=float, default=random.random())
    parser.add_argument('-e', '--end', nargs=2, type=int)
    arguments = parser.parse_args()

    parser.usage = "$ ./grid_cell_path.py -s <size_value> -d <maze_difficulty (float between 0 and 1)> -e <end_y> <end_x>"
    print("Failure to supply correct inputs will result random generation.")
    print(parser.usage)

    if(raw_input("\nPrint instructions, y/n? ") == "y"):
            print(instructions)
            raw_input("Press any key to continue.")

    # Sanity check inputs, and set up grid
    grid_size = arguments.size
    try:
        difficulty = arguments.difficulty
        assert(0 <= difficulty <= 1)
    except AssertionError:
        difficulty = random.random()

    try:
        end_cell = arguments.end
        assert(isinstance(end_cell, list))
        assert(0 < end_cell[0] < grid_size)
        assert(0 < end_cell[1] < grid_size)
    except:
        exc_type, exc_value, exc_traceback = sys.exc_info()
        if exc_type.__name__== "AssertionError":
            print("Unusable ending cell supplied, generating one randomly...")
        else:
            print("Unexpected exception occurred, quitting...")
            print(traceback.format_exc())
            sys.exit(1)
        end_cell = [random.randint(0,grid_size-1),random.randint(0,grid_size-1)]

    if end_cell == [0,0]:
        print("Beginning and ending cell are [0,0], shortest path is empty.")
        sys.exit(0)

    grid = generate_square_grid(grid_size, difficulty, end_cell)

    # Execute algorithm, then display shortest path and quit
    show(grid, "Grid:")
    print("Grid size: %d" % grid_size)
    print("Ending cell: " + str(end_cell))
    print("Traversal difficulty (0 implies no blocked cells, 1.0 implies an impossible-to-traverse grid): %f" % difficulty)
    path = shortest_path(grid, end_cell, grid_size)
    if not path:
        print("No path possible from [0,0] to " + str(end_cell))
    else:
        grid_with_path = fill_grid_with_path(grid, path)
        print("Shortest path: " + str(path) + "\n")
        show(grid_with_path, "Grid with path (represented by 2s): ")
    sys.exit(0)
