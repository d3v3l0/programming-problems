# Class 2 Prework
​
1. Review and implement "insertion sort" (we'll be using this as a building block during our next session).  When would you expect insertion sort to outperform quicksort, and vice versa?
​
2. Use timing / profiling tools in your language of choice to compare the performance of your quicksort and insertion sort implementations.
​
- Be mindful of overhead and random noise when making measurements
- Try a wide range of input sizes (e.g. 1 element up to 10,000 elements)
- Try a wide range of input patterns (e.g. mostly sorted, reversed, random)
​
Are your results in line with your expectations from Part 1?
​
3. Update your quicksort implementation to track the maximum recursive depth reached during execution.  What maximum recursive depths do you get for various input patterns (e.g. mostly sorted, reversed, random)?